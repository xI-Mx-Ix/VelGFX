/*
 * This file is part of VelGFX.
 * Licensed under LGPL 3.0.
 */
package net.xmx.velgfx.renderer.model.loader.gltf;

import de.javagl.jgltf.model.GltfModel;
import de.javagl.jgltf.model.MeshModel;
import de.javagl.jgltf.model.NodeModel;
import de.javagl.jgltf.model.SceneModel;
import net.xmx.velgfx.renderer.gl.VxDrawCommand;
import net.xmx.velgfx.renderer.model.skeleton.VxBone;
import net.xmx.velgfx.renderer.model.skeleton.VxNode;
import org.joml.Matrix4f;
import org.joml.Quaternionf;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Helper class to Translate the glTF Node hierarchy into the engine's internal structure.
 *
 * @author xI-Mx-Ix
 */
public class VxGltfStructure {

    /**
     * Temporary definition of a bone structure used during the loading phase.
     */
    public record BoneDefinition(int id, String name, Matrix4f offsetMatrix) {
    }

    /**
     * Recursively processes a glTF Node into a VxNode.
     * <p>
     * Converts glTF TRS (Translation, Rotation, Scale) or Matrix definitions into
     * a JOML Matrix4f.
     *
     * @param gltfNode The source node.
     * @param parent   The parent VxNode (can be null for root).
     * @return The constructed node hierarchy.
     */
    public static VxNode processNodeHierarchy(NodeModel gltfNode, VxNode parent) {
        Matrix4f localTransform = new Matrix4f();
        float[] matrixData = gltfNode.getMatrix();

        if (matrixData != null) {
            localTransform.set(matrixData);
        } else {
            float[] t = gltfNode.getTranslation();
            float[] r = gltfNode.getRotation();
            float[] s = gltfNode.getScale();

            if (t != null) localTransform.translate(t[0], t[1], t[2]);
            if (r != null) localTransform.rotate(new Quaternionf(r[0], r[1], r[2], r[3]));
            if (s != null) localTransform.scale(s[0], s[1], s[2]);
        }

        String name = gltfNode.getName();
        if (name == null || name.isEmpty()) {
            name = "Node_" + gltfNode.hashCode();
        }

        VxNode node = new VxNode(name, parent, localTransform);

        for (NodeModel child : gltfNode.getChildren()) {
            node.addChild(processNodeHierarchy(child, node));
        }
        return node;
    }

    /**
     * Maps flattened bone definitions to the actual Scene Nodes.
     *
     * @param definitions List of bone definitions extracted from the Skin.
     * @param root        The root node of the hierarchy.
     * @return The final list of runtime bones.
     */
    public static List<VxBone> buildSkeletonBones(List<BoneDefinition> definitions, VxNode root) {
        List<VxBone> finalBones = new ArrayList<>();
        for (BoneDefinition def : definitions) {
            VxNode node = root.findByName(def.name);
            if (node == null) {
                // Fallback to root to prevent crash if bone node is missing in hierarchy
                node = root;
            }
            finalBones.add(new VxBone(def.id, def.name, def.offsetMatrix, node));
        }
        return finalBones;
    }

    /**
     * Creates a mapping of Node Names to Draw Commands.
     * <p>
     * This method reconstructs the relationship between the Scene Graph (Nodes) and the
     * flat list of Draw Commands generated by the Geometry processor. It is essential for
     * <b>Rigid Body Animation</b>, where specific mesh parts must move with specific nodes.
     *
     * @param model       The full glTF model (required to access mesh list in order).
     * @param scene       The active scene model.
     * @param allCommands The flat list of commands generated by {@link VxGltfGeometry}.
     * @return A map where Key = Node Name, Value = List of Draw Commands for that node.
     */
    public static Map<String, List<VxDrawCommand>> mapNodesToCommands(GltfModel model, SceneModel scene, List<VxDrawCommand> allCommands) {
        // 1. Group Commands by MeshModel
        // VxGltfGeometry iterates: Model -> MeshModels -> Primitives.
        // We must replicate this order exactly to assign commands to meshes correctly.
        Map<MeshModel, List<VxDrawCommand>> meshToCommandsMap = new HashMap<>();
        int globalCommandIndex = 0;

        for (MeshModel mesh : model.getMeshModels()) {
            List<VxDrawCommand> meshCommands = new ArrayList<>();
            int primitiveCount = mesh.getMeshPrimitiveModels().size();

            // Collect the next N commands for this mesh
            for (int i = 0; i < primitiveCount; i++) {
                if (globalCommandIndex < allCommands.size()) {
                    meshCommands.add(allCommands.get(globalCommandIndex));
                    globalCommandIndex++;
                }
            }
            meshToCommandsMap.put(mesh, meshCommands);
        }

        // 2. Map Nodes to Mesh Commands
        Map<String, List<VxDrawCommand>> result = new HashMap<>();

        for (NodeModel node : scene.getNodeModels()) {
            recursiveNodeMapping(node, meshToCommandsMap, result);
        }

        return result;
    }

    /**
     * Recursively traverses the node tree to find Mesh attachments.
     */
    private static void recursiveNodeMapping(NodeModel node, Map<MeshModel, List<VxDrawCommand>> meshMap, Map<String, List<VxDrawCommand>> result) {
        // Retrieve all meshes attached to this node (usually 0 or 1 in glTF 2.0)
        for (MeshModel mesh : node.getMeshModels()) {
            List<VxDrawCommand> cmds = meshMap.get(mesh);

            if (cmds != null && !cmds.isEmpty()) {
                String name = node.getName();
                if (name == null || name.isEmpty()) {
                    name = "Node_" + node.hashCode();
                }

                // If a node has multiple meshes, we aggregate their commands into the same list
                result.computeIfAbsent(name, k -> new ArrayList<>()).addAll(cmds);
            }
        }

        // Continue traversal
        for (NodeModel child : node.getChildren()) {
            recursiveNodeMapping(child, meshMap, result);
        }
    }
}