/*
 * This file is part of VelGFX.
 * Licensed under LGPL 3.0.
 */
package net.xmx.velgfx.renderer.model.loader;

import net.xmx.velgfx.renderer.gl.VxDrawCommand;
import net.xmx.velgfx.renderer.gl.layout.VxSkinnedVertexLayout;
import net.xmx.velgfx.renderer.gl.layout.VxStaticVertexLayout;
import net.xmx.velgfx.renderer.gl.material.VxMaterial;
import org.lwjgl.assimp.*;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.*;

/**
 * Handles the extraction of mesh geometry from Assimp data structures.
 * <p>
 * This class converts {@link AIMesh} objects into flattened {@link ByteBuffer}s compatible
 * with the engine's vertex layouts (Static and Skinned). It handles:
 * <ul>
 *     <li>Packing positions, colors, UVs, normals, and tangents.</li>
 *     <li>Unpacking bone weights for skeletal animation.</li>
 *     <li>Generating draw commands for rendering.</li>
 * </ul>
 *
 * @author xI-Mx-Ix
 */
public class VxAssimpGeometry {

    /**
     * Flattens the scene meshes into a single vertex buffer using the {@link VxStaticVertexLayout}.
     *
     * @param scene The imported scene.
     * @param materials The parsed materials.
     * @param outCommands A list to populate with draw commands.
     * @return The ByteBuffer containing all static vertex data.
     */
    public static ByteBuffer processStaticGeometry(AIScene scene, List<VxMaterial> materials, List<VxDrawCommand> outCommands) {
        int numMeshes = scene.mNumMeshes();
        int totalVertices = 0;

        // Calculate total vertices (Faces * 3)
        for (int i = 0; i < numMeshes; i++) {
            AIMesh mesh = AIMesh.create(scene.mMeshes().get(i));
            totalVertices += mesh.mNumFaces() * 3;
        }

        // If 0 vertices, return empty buffer. This usually indicates .bin file failure in GLTF.
        if (totalVertices == 0) {
            return ByteBuffer.allocateDirect(0);
        }

        // Allocate off-heap buffer
        ByteBuffer buffer = ByteBuffer.allocateDirect(totalVertices * VxStaticVertexLayout.STRIDE).order(ByteOrder.nativeOrder());
        int vertexOffset = 0;

        for (int i = 0; i < numMeshes; i++) {
            AIMesh aiMesh = AIMesh.create(scene.mMeshes().get(i));
            VxMaterial mat = materials.get(aiMesh.mMaterialIndex());
            int count = aiMesh.mNumFaces() * 3;

            writeStaticMeshToBuffer(buffer, aiMesh);

            outCommands.add(new VxDrawCommand(mat, vertexOffset, count));
            vertexOffset += count;
        }

        buffer.flip();
        return buffer;
    }

    /**
     * Writes mesh data to the buffer, including Tangents for Normal Mapping.
     */
    private static void writeStaticMeshToBuffer(ByteBuffer buffer, AIMesh mesh) {
        AIVector3D.Buffer verts = mesh.mVertices();
        AIVector3D.Buffer norms = mesh.mNormals();
        AIVector3D.Buffer uvs = mesh.mTextureCoords(0);
        AIVector3D.Buffer tans = mesh.mTangents(); // Generated by aiProcess_CalcTangentSpace
        AIFace.Buffer faces = mesh.mFaces();

        int numFaces = mesh.mNumFaces();

        for (int i = 0; i < numFaces; i++) {
            AIFace face = faces.get(i);

            // Assume triangles due to aiProcess_Triangulate
            for (int j = 0; j < face.mNumIndices(); j++) {
                int index = face.mIndices().get(j);

                AIVector3D v = verts.get(index);
                AIVector3D n = (norms != null) ? norms.get(index) : null;
                AIVector3D uv = (uvs != null) ? uvs.get(index) : null;
                AIVector3D t = (tans != null) ? tans.get(index) : null;

                // 1. Position (3 floats)
                buffer.putFloat(v.x()).putFloat(v.y()).putFloat(v.z());

                // 2. Color (4 bytes) - Default White
                buffer.putInt(0xFFFFFFFF);

                // 3. UV0 (2 floats)
                if (uv != null) buffer.putFloat(uv.x()).putFloat(uv.y());
                else buffer.putFloat(0f).putFloat(0f);

                // 4. UV2 Lightmap (2 shorts)
                buffer.putShort((short) 0).putShort((short) 0);

                // 5. Normal (3 bytes, normalized to byte range)
                if (n != null) {
                    buffer.put((byte) (n.x() * 127)).put((byte) (n.y() * 127)).put((byte) (n.z() * 127));
                } else {
                    buffer.put((byte) 0).put((byte) 127).put((byte) 0);
                }

                // 6. Tangent (4 bytes) - Critical for Normal Maps
                if (t != null) {
                    buffer.put((byte) (t.x() * 127)).put((byte) (t.y() * 127)).put((byte) (t.z() * 127)).put((byte) 127);
                } else {
                    buffer.put((byte) 127).put((byte) 0).put((byte) 0).put((byte) 127);
                }

                // 7. Padding/Alignment
                buffer.put((byte) 0);

                // 8. Extra UV Data (MidTexCoord)
                if (uv != null) buffer.putFloat(uv.x()).putFloat(uv.y());
                else buffer.putFloat(0f).putFloat(0f);
            }
        }
    }

    /**
     * Flattens geometry into the {@link VxSkinnedVertexLayout}, including bone weights.
     *
     * @param scene The imported scene.
     * @param materials The parsed materials.
     * @param outCommands A list to populate with draw commands.
     * @param boneDefinitions A list to populate with discovered bone definitions.
     * @return The ByteBuffer containing skinned vertex data.
     */
    public static ByteBuffer processSkinnedGeometry(AIScene scene, List<VxMaterial> materials, List<VxDrawCommand> outCommands, List<VxAssimpStructure.BoneDefinition> boneDefinitions) {
        int numMeshes = scene.mNumMeshes();
        int totalVertices = 0;

        for (int i = 0; i < numMeshes; i++) {
            totalVertices += AIMesh.create(scene.mMeshes().get(i)).mNumFaces() * 3;
        }

        ByteBuffer buffer = ByteBuffer.allocateDirect(totalVertices * VxSkinnedVertexLayout.STRIDE).order(ByteOrder.nativeOrder());
        int vertexOffset = 0;

        // Map to ensure global uniqueness of bone IDs across meshes
        Map<String, Integer> globalBoneIndexMap = new HashMap<>();

        for (int i = 0; i < numMeshes; i++) {
            AIMesh aiMesh = AIMesh.create(scene.mMeshes().get(i));
            VxMaterial mat = materials.get(aiMesh.mMaterialIndex());
            int count = aiMesh.mNumFaces() * 3;

            writeSkinnedMeshToBuffer(buffer, aiMesh, globalBoneIndexMap, boneDefinitions);

            outCommands.add(new VxDrawCommand(mat, vertexOffset, count));
            vertexOffset += count;
        }

        buffer.flip();
        return buffer;
    }

    private static void writeSkinnedMeshToBuffer(ByteBuffer buffer, AIMesh mesh, Map<String, Integer> globalBoneMap, List<VxAssimpStructure.BoneDefinition> boneDefs) {
        int originalVertexCount = mesh.mNumVertices();

        // Temporary arrays to hold weights before unrolling faces
        float[] tempWeights = new float[originalVertexCount * 4];
        float[] tempIndices = new float[originalVertexCount * 4];
        Arrays.fill(tempIndices, 0f);

        // Process Bone Weights
        for (int i = 0; i < mesh.mNumBones(); i++) {
            AIBone aiBone = AIBone.create(mesh.mBones().get(i));
            String name = aiBone.mName().dataString();

            int boneId = globalBoneMap.computeIfAbsent(name, k -> {
                int newId = boneDefs.size();
                boneDefs.add(new VxAssimpStructure.BoneDefinition(newId, name, VxAssimpStructure.toJomlMatrix(aiBone.mOffsetMatrix())));
                return newId;
            });

            for (int wIdx = 0; wIdx < aiBone.mNumWeights(); wIdx++) {
                AIVertexWeight w = aiBone.mWeights().get(wIdx);
                int vertexId = w.mVertexId();
                float weightVal = w.mWeight();

                for (int slot = 0; slot < 4; slot++) {
                    if (tempWeights[vertexId * 4 + slot] == 0f) {
                        tempWeights[vertexId * 4 + slot] = weightVal;
                        tempIndices[vertexId * 4 + slot] = (float) boneId;
                        break;
                    }
                }
            }
        }

        // Write Vertex Data
        AIVector3D.Buffer verts = mesh.mVertices();
        AIVector3D.Buffer uvs = mesh.mTextureCoords(0);
        AIVector3D.Buffer norms = mesh.mNormals();
        AIVector3D.Buffer tans = mesh.mTangents();
        AIFace.Buffer faces = mesh.mFaces();
        int numFaces = mesh.mNumFaces();

        for (int i = 0; i < numFaces; i++) {
            AIFace face = faces.get(i);

            for (int j = 0; j < face.mNumIndices(); j++) {
                int idx = face.mIndices().get(j);

                AIVector3D v = verts.get(idx);
                AIVector3D uv = (uvs != null) ? uvs.get(idx) : null;
                AIVector3D n = (norms != null) ? norms.get(idx) : null;
                AIVector3D t = (tans != null) ? tans.get(idx) : null;

                // Pos
                buffer.putFloat(v.x()).putFloat(v.y()).putFloat(v.z());
                // UV
                if (uv != null) buffer.putFloat(uv.x()).putFloat(uv.y());
                else buffer.putFloat(0f).putFloat(0f);
                // Normal
                if (n != null) buffer.putFloat(n.x()).putFloat(n.y()).putFloat(n.z());
                else buffer.putFloat(0f).putFloat(1f).putFloat(0f);
                // Tangent
                if (t != null) buffer.putFloat(t.x()).putFloat(t.y()).putFloat(t.z()).putFloat(1f);
                else buffer.putFloat(1f).putFloat(0f).putFloat(0f).putFloat(1f);

                // Weights & Indices
                int baseIdx = idx * 4;
                buffer.putFloat(tempWeights[baseIdx]).putFloat(tempWeights[baseIdx + 1])
                        .putFloat(tempWeights[baseIdx + 2]).putFloat(tempWeights[baseIdx + 3]);
                buffer.putFloat(tempIndices[baseIdx]).putFloat(tempIndices[baseIdx + 1])
                        .putFloat(tempIndices[baseIdx + 2]).putFloat(tempIndices[baseIdx + 3]);
            }
        }
    }
}